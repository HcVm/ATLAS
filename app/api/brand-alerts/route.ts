import { createServerClient } from "@/lib/supabase-server"
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

// Define types for clarity
interface BrandAlert {
  id?: string // Optional because it might be generated by DB
  orden_electronica: string
  acuerdo_marco: string
  brand_name: string
  status: "pending" | "attended" | "rejected"
  notes?: string | null
  ruc_proveedor?: string | null
  razon_social_proveedor?: string | null
  estado_orden_electronica?: string | null
  created_at?: string
  updated_at?: string
}

interface OpenDataEntry {
  id: number
  orden_electronica?: string
  codigo_acuerdo_marco?: string
  acuerdo_marco?: string
  marca_ficha_producto?: string // Only this column will be used for brand detection
  ruc_proveedor?: string
  razon_social_proveedor?: string
  estado_orden_electronica?: string
}

// Define las marcas base y sus patrones de búsqueda
const BASE_MONITORED_BRANDS = ["WORLDLIFE", "HOPE LIFE", "ZEUS", "VALHALLA"]

// Crea un mapa de patrones de búsqueda más completo
const ALL_BRAND_SEARCH_PATTERNS = new Map<string, string>()

// Para cada marca base, agregar múltiples patrones de búsqueda
BASE_MONITORED_BRANDS.forEach((brand) => {
  // Patrón exacto
  ALL_BRAND_SEARCH_PATTERNS.set(brand, brand)

  // Patrón con "MARCA: "
  ALL_BRAND_SEARCH_PATTERNS.set(`MARCA: ${brand}`, brand)

  // Patrón con "MARCA:" (sin espacio)
  ALL_BRAND_SEARCH_PATTERNS.set(`MARCA:${brand}`, brand)

  // Patrón con "MARCA " (sin dos puntos)
  ALL_BRAND_SEARCH_PATTERNS.set(`MARCA ${brand}`, brand)

  // Patrón con minúsculas
  ALL_BRAND_SEARCH_PATTERNS.set(`marca: ${brand.toLowerCase()}`, brand)
  ALL_BRAND_SEARCH_PATTERNS.set(`marca:${brand.toLowerCase()}`, brand)
  ALL_BRAND_SEARCH_PATTERNS.set(`marca ${brand.toLowerCase()}`, brand)

  // Patrones adicionales para casos específicos
  if (brand === "HOPE LIFE") {
    ALL_BRAND_SEARCH_PATTERNS.set("HOPELIFE", brand)
    ALL_BRAND_SEARCH_PATTERNS.set("MARCA: HOPELIFE", brand)
    ALL_BRAND_SEARCH_PATTERNS.set("MARCA:HOPELIFE", brand)
    ALL_BRAND_SEARCH_PATTERNS.set("Hope Life", brand)
    ALL_BRAND_SEARCH_PATTERNS.set("HopeLife", brand)
  }
})

console.log("Brand search patterns configured:", Array.from(ALL_BRAND_SEARCH_PATTERNS.keys()))

/**
 * Ensures the brand_alerts table exists with correct constraints and is populated from open_data_entries.
 */
async function ensureBrandAlertsPopulated(supabase: any) {
  console.log("ensureBrandAlertsPopulated: Starting population process...")

  try {
    // 1. First, ensure the table has the correct constraint
    console.log("ensureBrandAlertsPopulated: Checking and fixing table constraints...")

    // Drop the incorrect constraint if it exists and create the correct one
    try {
      await supabase.rpc("fix_brand_alerts_constraint")
    } catch (constraintError) {
      console.log("ensureBrandAlertsPopulated: Constraint fix not available, continuing...")
    }

    // 2. Fetch existing alerts for deduplication
    console.log("ensureBrandAlertsPopulated: Fetching existing alerts for deduplication...")
    const { data: existingAlerts, error: existingError } = await supabase
      .from("brand_alerts")
      .select("orden_electronica, brand_name")

    if (existingError) {
      console.error("ensureBrandAlertsPopulated: Error fetching existing alerts for deduplication:", existingError)
      // Continue without deduplication if there's an error fetching existing alerts
    }

    const existingAlertsTyped = (existingAlerts as Pick<BrandAlert, "orden_electronica" | "brand_name">[]) || []
    const existingAlertsSet = new Set(existingAlertsTyped.map((a) => `${a.orden_electronica}-${a.brand_name}`))
    console.log(`ensureBrandAlertsPopulated: Found ${existingAlertsTyped.length} existing alerts in DB.`)

    const alertsToInsert: BrandAlert[] = []
    const BATCH_SIZE = 1000 // Define a batch size for pagination
    let offset = 0
    let hasMore = true
    let totalOpenDataEntriesProcessed = 0

    // 3. Fetch relevant open_data_entries in batches for brand detection
    while (hasMore) {
      console.log(`ensureBrandAlertsPopulated: Fetching open_data_entries batch from offset ${offset}...`)

      // Buscar en TODOS los acuerdos marco, no solo uno específico
      const { data: openDataEntriesBatch, error: openDataError } = await supabase
        .from("open_data_entries")
        .select("id, orden_electronica, codigo_acuerdo_marco, acuerdo_marco, marca_ficha_producto, ruc_proveedor, razon_social_proveedor, estado_orden_electronica")
        .not("marca_ficha_producto", "is", null) // Solo registros que tengan marca_ficha_producto
        .range(offset, offset + BATCH_SIZE - 1) // Fetch BATCH_SIZE records

      if (openDataError) {
        console.error("ensureBrandAlertsPopulated: Error fetching open data batch:", openDataError)
        hasMore = false // Stop if there's an error
        break
      }

      const openDataEntriesTyped = (openDataEntriesBatch as OpenDataEntry[]) || []
      totalOpenDataEntriesProcessed += openDataEntriesTyped.length
      console.log(
        `ensureBrandAlertsPopulated: Fetched ${openDataEntriesTyped.length} entries in this batch. Total processed: ${totalOpenDataEntriesProcessed}`,
      )

      if (openDataEntriesTyped.length === 0 || openDataEntriesTyped.length < BATCH_SIZE) {
        hasMore = false // No more data or last batch was smaller than BATCH_SIZE
      } else {
        offset += BATCH_SIZE
      }

      // Process the current batch
      for (const entry of openDataEntriesTyped) {
        const searchText = (entry.marca_ficha_producto || "").toUpperCase().trim()

        if (!searchText) continue // Skip empty marca_ficha_producto

        let detectedBrand = ""
        let matchedPattern = ""

        // Itera sobre los patrones de búsqueda definidos
        for (const [pattern, baseBrand] of ALL_BRAND_SEARCH_PATTERNS.entries()) {
          const upperPattern = pattern.toUpperCase()
          if (searchText.includes(upperPattern)) {
            detectedBrand = baseBrand // Asigna el nombre de marca base
            matchedPattern = pattern
            break // Found a brand, no need to check others for this entry
          }
        }

        if (detectedBrand) {
          const ordenElectronica = entry.orden_electronica || `OE-${entry.id}` // Fallback if orden_electronica is null
          const uniqueKey = `${ordenElectronica}-${detectedBrand}`

          if (!existingAlertsSet.has(uniqueKey)) {
            // Usar acuerdo_marco completo si está disponible, sino usar codigo_acuerdo_marco
            const acuerdoMarco = entry.acuerdo_marco || entry.codigo_acuerdo_marco || "Unknown"

            alertsToInsert.push({
              orden_electronica: ordenElectronica,
              acuerdo_marco: acuerdoMarco,
              brand_name: detectedBrand, // Usa el nombre de marca base
              status: "pending", // New alerts are always pending
              notes: `Detectado automáticamente en marca_ficha_producto: "${entry.marca_ficha_producto || "N/A"}" usando patrón: "${matchedPattern}"`,
              ruc_proveedor: entry.ruc_proveedor || null,
              razon_social_proveedor: entry.razon_social_proveedor || null,
              estado_orden_electronica: entry.estado_orden_electronica || null,
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString(),
            })
            existingAlertsSet.add(uniqueKey) // Add to set to prevent duplicates within the same batch
            console.log(
              `ensureBrandAlertsPopulated: Detected brand "${detectedBrand}" in "${entry.marca_ficha_producto}" (pattern: "${matchedPattern}") for OE: ${ordenElectronica}. Acuerdo: ${acuerdoMarco}. Proveedor: ${entry.razon_social_proveedor || 'N/A'}`,
            )
          }
        }
      }
    }

    console.log(
      `ensureBrandAlertsPopulated: Finished processing all open_data_entries. Total entries processed: ${totalOpenDataEntriesProcessed}`,
    )
    console.log(`ensureBrandAlertsPopulated: Prepared ${alertsToInsert.length} new alerts for insertion.`)

    // 4. Insert new alerts into brand_alerts table using individual inserts to handle conflicts
    if (alertsToInsert.length > 0) {
      console.log("ensureBrandAlertsPopulated: Attempting to insert alerts individually...")

      let insertedCount = 0
      let skippedCount = 0

      for (const alert of alertsToInsert) {
        try {
          const { error: insertError } = await supabase.from("brand_alerts").insert([alert])

          if (insertError) {
            if (insertError.code === "23505") {
              // Duplicate key error - skip this one
              skippedCount++
              console.log(
                `ensureBrandAlertsPopulated: Skipped duplicate alert for OE: ${alert.orden_electronica}, Brand: ${alert.brand_name}`,
              )
            } else {
              console.error(
                `ensureBrandAlertsPopulated: Error inserting alert for OE: ${alert.orden_electronica}:`,
                insertError,
              )
            }
          } else {
            insertedCount++
            if (insertedCount % 10 === 0) {
              console.log(`ensureBrandAlertsPopulated: Inserted ${insertedCount} alerts so far...`)
            }
          }
        } catch (error) {
          console.error(
            `ensureBrandAlertsPopulated: Unexpected error inserting alert for OE: ${alert.orden_electronica}:`,
            error,
          )
        }
      }

      console.log(
        `ensureBrandAlertsPopulated: Insertion complete. Inserted: ${insertedCount}, Skipped: ${skippedCount}`,
      )
    } else {
      console.log("ensureBrandAlertsPopulated: No new brand alerts to insert.")
    }
  } catch (error) {
    console.error("ensureBrandAlertsPopulated: Unhandled error during population:", error)
  }
}

export async function GET(request: NextRequest) {
  const supabase = createServerClient()
  const { searchParams } = new URL(request.url)
  const status = searchParams.get("status")

  try {
    console.log("API GET: Request received for brand alerts with status:", status || "all")

    // 1. Check if brand_alerts table is empty. If so, trigger population.
    console.log("API GET: Checking brand_alerts table count...")
    const { count: alertsCount, error: countError } = await supabase
      .from("brand_alerts")
      .select("*", { count: "exact", head: true })

    if (countError) {
      console.error("API GET: Error checking brand_alerts count:", countError)
      // Proceed, but log the error. The ensure function might still work.
    }

    if (alertsCount === 0) {
      console.log("API GET: brand_alerts table is empty. Triggering population...")
      await ensureBrandAlertsPopulated(supabase)
      // After population, re-check count to confirm data is there
      const { count: newAlertsCount } = await supabase.from("brand_alerts").select("*", { count: "exact", head: true })
      console.log(`API GET: After population, brand_alerts table has ${newAlertsCount} records.`)
    } else {
      console.log(`API GET: brand_alerts table has ${alertsCount} records.`)
    }

    // 2. Fetch the data from brand_alerts based on status filter
    console.log("API GET: Fetching alerts from brand_alerts table...")
    let query = supabase.from("brand_alerts").select("*").order("created_at", { ascending: false })

    if (status && ["pending", "attended", "rejected"].includes(status)) {
      query = query.eq("status", status)
      console.log(`API GET: Applying status filter: ${status}`)
    }

    const { data, error } = await query

    if (error) {
      console.error("API GET: Error fetching brand alerts from database:", error)
      return NextResponse.json({ error: "Failed to fetch brand alerts" }, { status: 500 })
    }

    console.log("API GET: Successfully retrieved", data?.length, "alerts.")
    if (data && data.length > 0) {
      console.log("API GET: Data sample:", data.slice(0, 2)) // Log a sample of the data
    } else {
      console.log("API GET: No data retrieved from brand_alerts.")
    }

    return NextResponse.json({ data })
  } catch (error) {
    console.error("API GET: Unhandled error in brand alerts GET API:", error)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}

export async function PATCH(request: NextRequest) {
  const supabase = createServerClient()

  try {
    console.log("API PATCH: Request received to update brand alert.")
    const body = await request.json()
    const { id, status, notes } = body

    if (!id || !status) {
      console.error("API PATCH: Missing ID or status in request body.")
      return NextResponse.json({ error: "ID and status are required" }, { status: 400 })
    }

    if (!["pending", "attended", "rejected"].includes(status)) {
      console.error("API PATCH: Invalid status provided:", status)
      return NextResponse.json({ error: "Invalid status" }, { status: 400 })
    }

    console.log(`API PATCH: Updating alert ID: ${id} to status: ${status}`)
    const { data, error } = await supabase
      .from("brand_alerts")
      .update({
        status,
        notes: notes || null,
        updated_at: new Date().toISOString(),
      })
      .eq("id", id)
      .select()

    if (error) {
      console.error("API PATCH: Error updating brand alert:", error)
      return NextResponse.json({ error: "Failed to update brand alert" }, { status: 500 })
    }

    if (!data || data.length === 0) {
      console.warn(`API PATCH: No alert found with ID: ${id} to update.`)
      return NextResponse.json({ error: "Alert not found" }, { status: 404 })
    }

    console.log("API PATCH: Successfully updated brand alert.", data)
    return NextResponse.json({ data })
  } catch (error) {
    console.error("API PATCH: Unhandled error in brand alerts PATCH API:", error)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}
