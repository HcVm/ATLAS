import { createServerClient } from "@/lib/supabase-server"
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

// Define types for clarity
interface BrandAlert {
  id?: string // Optional because it might be generated by DB
  orden_electronica: string
  acuerdo_marco: string
  brand_name: string
  status: "pending" | "attended" | "rejected"
  notes?: string | null
  created_at?: string
  updated_at?: string
}

interface OpenDataEntry {
  id: number
  orden_electronica?: string
  codigo_acuerdo_marco?: string
  marca_ficha_producto?: string // Only this column will be used for brand detection
}

// Define las marcas base y sus patrones de búsqueda
const BASE_MONITORED_BRANDS = ["WORLDLIFE", "HOPE LIFE", "ZEUS", "VALHALLA"]

// Crea un mapa de patrones de búsqueda a sus nombres de marca base
const ALL_BRAND_SEARCH_PATTERNS = new Map<string, string>()
BASE_MONITORED_BRANDS.forEach((brand) => {
  ALL_BRAND_SEARCH_PATTERNS.set(brand, brand) // Ej: "ZEUS" -> "ZEUS"
  ALL_BRAND_SEARCH_PATTERNS.set(`MARCA: ${brand}`, brand) // Ej: "MARCA: ZEUS" -> "ZEUS"
  ALL_BRAND_SEARCH_PATTERNS.set(`MARCA:${brand}`, brand) // Ej: "MARCA:ZEUS" -> "ZEUS"
})

/**
 * Ensures the brand_alerts table is populated from open_data_entries if it's empty.
 * It also deduplicates entries based on orden_electronica and brand_name.
 */
async function ensureBrandAlertsPopulated(supabase: any) {
  console.log("ensureBrandAlertsPopulated: Starting population process...")

  try {
    // 1. Fetch existing alerts for deduplication
    console.log("ensureBrandAlertsPopulated: Fetching existing alerts for deduplication...")
    const { data: existingAlerts, error: existingError } = await supabase
      .from("brand_alerts")
      .select("orden_electronica, brand_name")

    if (existingError) {
      console.error("ensureBrandAlertsPopulated: Error fetching existing alerts for deduplication:", existingError)
      // Continue without deduplication if there's an error fetching existing alerts
    }

    const existingAlertsTyped = (existingAlerts as Pick<BrandAlert, "orden_electronica" | "brand_name">[]) || []
    const existingAlertsSet = new Set(existingAlertsTyped.map((a) => `${a.orden_electronica}-${a.brand_name}`))
    console.log(`ensureBrandAlertsPopulated: Found ${existingAlertsTyped.length} existing alerts in DB.`)

    const alertsToInsert: BrandAlert[] = []
    const BATCH_SIZE = 1000 // Define a batch size for pagination
    let offset = 0
    let hasMore = true
    let totalOpenDataEntriesProcessed = 0

    // 2. Fetch relevant open_data_entries in batches for brand detection
    while (hasMore) {
      console.log(`ensureBrandAlertsPopulated: Fetching open_data_entries batch from offset ${offset}...`)
      const { data: openDataEntriesBatch, error: openDataError } = await supabase
        .from("open_data_entries")
        .select("id, orden_electronica, codigo_acuerdo_marco, marca_ficha_producto")
        .range(offset, offset + BATCH_SIZE - 1) // Fetch BATCH_SIZE records

      if (openDataError) {
        console.error("ensureBrandAlertsPopulated: Error fetching open data batch:", openDataError)
        hasMore = false // Stop if there's an error
        break
      }

      const openDataEntriesTyped = (openDataEntriesBatch as OpenDataEntry[]) || []
      totalOpenDataEntriesProcessed += openDataEntriesTyped.length
      console.log(
        `ensureBrandAlertsPopulated: Fetched ${openDataEntriesTyped.length} entries in this batch. Total processed: ${totalOpenDataEntriesProcessed}`,
      )

      if (openDataEntriesTyped.length === 0 || openDataEntriesTyped.length < BATCH_SIZE) {
        hasMore = false // No more data or last batch was smaller than BATCH_SIZE
      } else {
        offset += BATCH_SIZE
      }

      // Process the current batch
      for (const entry of openDataEntriesTyped) {
        const searchText = (entry.marca_ficha_producto || "").toUpperCase()

        let detectedBrand = ""
        // Itera sobre los patrones de búsqueda definidos
        for (const [pattern, baseBrand] of ALL_BRAND_SEARCH_PATTERNS.entries()) {
          if (searchText.includes(pattern)) {
            detectedBrand = baseBrand // Asigna el nombre de marca base
            break // Found a brand, no need to check others for this entry
          }
        }

        if (detectedBrand) {
          const ordenElectronica = entry.orden_electronica || `OE-${entry.id}` // Fallback if orden_electronica is null
          const uniqueKey = `${ordenElectronica}-${detectedBrand}`

          if (!existingAlertsSet.has(uniqueKey)) {
            alertsToInsert.push({
              orden_electronica: ordenElectronica,
              acuerdo_marco: entry.codigo_acuerdo_marco || "Unknown",
              brand_name: detectedBrand, // Usa el nombre de marca base
              status: "pending", // New alerts are always pending
              notes: `Detectado automáticamente en marca_ficha_producto: "${entry.marca_ficha_producto || "N/A"}" usando patrón: "${searchText}"`,
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString(),
            })
            existingAlertsSet.add(uniqueKey) // Add to set to prevent duplicates within the same batch
            console.log(
              `ensureBrandAlertsPopulated: Detected brand "${detectedBrand}" in "${entry.marca_ficha_producto}" (processed as "${searchText}") for OE: ${ordenElectronica}. New alert added.`,
            )
          }
        }
      }
    }
    console.log(
      `ensureBrandAlertsPopulated: Finished processing all open_data_entries. Total entries processed: ${totalOpenDataEntriesProcessed}`,
    )
    console.log(`ensureBrandAlertsPopulated: Prepared ${alertsToInsert.length} new alerts for insertion.`)

    // 3. Insert/Upsert new alerts into brand_alerts table
    if (alertsToInsert.length > 0) {
      console.log("ensureBrandAlertsPopulated: Attempting to upsert alerts...")
      const { error: insertError } = await supabase
        .from("brand_alerts")
        .upsert(alertsToInsert, { onConflict: "orden_electronica,brand_name" }) // Use onConflict for upsert

      if (insertError) {
        console.error("ensureBrandAlertsPopulated: Error upserting brand alerts:", insertError)
      } else {
        console.log("ensureBrandAlertsPopulated: Successfully upserted brand_alerts table.")
      }
    } else {
      console.log("ensureBrandAlertsPopulated: No new brand alerts to upsert.")
    }
  } catch (error) {
    console.error("ensureBrandAlertsPopulated: Unhandled error during population:", error)
  }
}

export async function GET(request: NextRequest) {
  const supabase = createServerClient()
  const { searchParams } = new URL(request.url)
  const status = searchParams.get("status")

  try {
    console.log("API GET: Request received for brand alerts with status:", status || "all")

    // 1. Check if brand_alerts table is empty. If so, trigger population.
    console.log("API GET: Checking brand_alerts table count...")
    const { count: alertsCount, error: countError } = await supabase
      .from("brand_alerts")
      .select("*", { count: "exact", head: true })

    if (countError) {
      console.error("API GET: Error checking brand_alerts count:", countError)
      // Proceed, but log the error. The ensure function might still work.
    }

    if (alertsCount === 0) {
      console.log("API GET: brand_alerts table is empty. Triggering population...")
      await ensureBrandAlertsPopulated(supabase)
      // After population, re-check count to confirm data is there
      const { count: newAlertsCount } = await supabase.from("brand_alerts").select("*", { count: "exact", head: true })
      console.log(`API GET: After population, brand_alerts table has ${newAlertsCount} records.`)
    } else {
      console.log(`API GET: brand_alerts table has ${alertsCount} records.`)
    }

    // 2. Fetch the data from brand_alerts based on status filter
    console.log("API GET: Fetching alerts from brand_alerts table...")
    let query = supabase.from("brand_alerts").select("*").order("created_at", { ascending: false })

    if (status && ["pending", "attended", "rejected"].includes(status)) {
      query = query.eq("status", status)
      console.log(`API GET: Applying status filter: ${status}`)
    }

    const { data, error } = await query

    if (error) {
      console.error("API GET: Error fetching brand alerts from database:", error)
      return NextResponse.json({ error: "Failed to fetch brand alerts" }, { status: 500 })
    }

    console.log("API GET: Successfully retrieved", data?.length, "alerts.")
    if (data && data.length > 0) {
      console.log("API GET: Data sample:", data.slice(0, 2)) // Log a sample of the data
    } else {
      console.log("API GET: No data retrieved from brand_alerts.")
    }

    return NextResponse.json({ data })
  } catch (error) {
    console.error("API GET: Unhandled error in brand alerts GET API:", error)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}

export async function PATCH(request: NextRequest) {
  const supabase = createServerClient()

  try {
    console.log("API PATCH: Request received to update brand alert.")
    const body = await request.json()
    const { id, status, notes } = body

    if (!id || !status) {
      console.error("API PATCH: Missing ID or status in request body.")
      return NextResponse.json({ error: "ID and status are required" }, { status: 400 })
    }

    if (!["pending", "attended", "rejected"].includes(status)) {
      console.error("API PATCH: Invalid status provided:", status)
      return NextResponse.json({ error: "Invalid status" }, { status: 400 })
    }

    console.log(`API PATCH: Updating alert ID: ${id} to status: ${status}`)
    const { data, error } = await supabase
      .from("brand_alerts")
      .update({
        status,
        notes: notes || null,
        updated_at: new Date().toISOString(),
      })
      .eq("id", id)
      .select()

    if (error) {
      console.error("API PATCH: Error updating brand alert:", error)
      return NextResponse.json({ error: "Failed to update brand alert" }, { status: 500 })
    }

    if (!data || data.length === 0) {
      console.warn(`API PATCH: No alert found with ID: ${id} to update.`)
      return NextResponse.json({ error: "Alert not found" }, { status: 404 })
    }

    console.log("API PATCH: Successfully updated brand alert.", data)
    return NextResponse.json({ data })
  } catch (error) {
    console.error("API PATCH: Unhandled error in brand alerts PATCH API:", error)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}
